/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * TechBay
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as url from 'url';
import * as portableFetch from 'portable-fetch';
import type { Configuration } from './configuration';

const BASE_PATH = 'https://techbay.ecsc.io/api'.replace(/\/+$/, '');

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|',
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = portableFetch,
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name: 'RequiredError';
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 *
 * @export
 * @interface LoginCredentials
 */
export interface LoginCredentials {
  /**
   *
   * @type {string}
   * @memberof LoginCredentials
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof LoginCredentials
   */
  hashedPassword: string;
}

/**
 *
 * @export
 * @interface MyOffer
 */
export interface MyOffer {
  /**
   *
   * @type {number}
   * @memberof MyOffer
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof MyOffer
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof MyOffer
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof MyOffer
   */
  picture: string;
  /**
   *
   * @type {number}
   * @memberof MyOffer
   */
  timestamp: number;
  /**
   *
   * @type {boolean}
   * @memberof MyOffer
   */
  isRequestedByMe: boolean;
  /**
   *
   * @type {any}
   * @memberof MyOffer
   */
  creator: any;
  /**
   *
   * @type {any}
   * @memberof MyOffer
   */
  owner?: any;
}

/**
 *
 * @export
 * @interface NewOffer
 */
export interface NewOffer {
  /**
   *
   * @type {string}
   * @memberof NewOffer
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof NewOffer
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof NewOffer
   */
  picture?: string;
}

/**
 *
 * @export
 * @interface NewUser
 */
export interface NewUser {
  /**
   *
   * @type {string}
   * @memberof NewUser
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof NewUser
   */
  hashedPassword: string;
  /**
   *
   * @type {string}
   * @memberof NewUser
   */
  passport: string;
}

/**
 *
 * @export
 * @interface Offer
 */
export interface Offer {
  /**
   *
   * @type {number}
   * @memberof Offer
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof Offer
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Offer
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof Offer
   */
  picture: string;
  /**
   *
   * @type {number}
   * @memberof Offer
   */
  timestamp: number;
  /**
   *
   * @type {boolean}
   * @memberof Offer
   */
  isRequestedByMe: boolean;
  /**
   *
   * @type {any}
   * @memberof Offer
   */
  creator: any;
  /**
   *
   * @type {any}
   * @memberof Offer
   */
  owner?: any;
}

/**
 *
 * @export
 * @interface ProfileInfo
 */
export interface ProfileInfo {
  /**
   *
   * @type {number}
   * @memberof ProfileInfo
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof ProfileInfo
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof ProfileInfo
   */
  displayname: string;
  /**
   *
   * @type {string}
   * @memberof ProfileInfo
   */
  address?: string;
  /**
   *
   * @type {string}
   * @memberof ProfileInfo
   */
  telephoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof ProfileInfo
   */
  status?: string;
}

/**
 *
 * @export
 * @interface ProfileInfoCurrentUser
 */
export interface ProfileInfoCurrentUser {
  /**
   *
   * @type {number}
   * @memberof ProfileInfoCurrentUser
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof ProfileInfoCurrentUser
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof ProfileInfoCurrentUser
   */
  displayname?: string;
  /**
   *
   * @type {string}
   * @memberof ProfileInfoCurrentUser
   */
  address?: string;
  /**
   *
   * @type {boolean}
   * @memberof ProfileInfoCurrentUser
   */
  isAddressPublic?: boolean;
  /**
   *
   * @type {string}
   * @memberof ProfileInfoCurrentUser
   */
  telephoneNumber?: string;
  /**
   *
   * @type {boolean}
   * @memberof ProfileInfoCurrentUser
   */
  isTelephoneNumberPublic?: boolean;
  /**
   *
   * @type {string}
   * @memberof ProfileInfoCurrentUser
   */
  status?: string;
  /**
   *
   * @type {boolean}
   * @memberof ProfileInfoCurrentUser
   */
  isStatusPublic?: boolean;
}

/**
 *
 * @export
 * @interface ProfileUpdateInfo
 */
export interface ProfileUpdateInfo {
  /**
   *
   * @type {string}
   * @memberof ProfileUpdateInfo
   */
  displayname?: string;
  /**
   *
   * @type {string}
   * @memberof ProfileUpdateInfo
   */
  address?: string;
  /**
   *
   * @type {boolean}
   * @memberof ProfileUpdateInfo
   */
  isAddressPublic?: boolean;
  /**
   *
   * @type {string}
   * @memberof ProfileUpdateInfo
   */
  telephoneNumber?: string;
  /**
   *
   * @type {boolean}
   * @memberof ProfileUpdateInfo
   */
  isTelephoneNumberPublic?: boolean;
  /**
   *
   * @type {string}
   * @memberof ProfileUpdateInfo
   */
  status?: string;
  /**
   *
   * @type {boolean}
   * @memberof ProfileUpdateInfo
   */
  isStatusPublic?: boolean;
}

/**
 *
 * @export
 * @interface Request
 */
export interface Request {
  /**
   *
   * @type {number}
   * @memberof Request
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof Request
   */
  userId: number;
  /**
   *
   * @type {number}
   * @memberof Request
   */
  offerId: number;
  /**
   *
   * @type {number}
   * @memberof Request
   */
  timestamp: number;
}

/**
 *
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
  /**
   *
   * @type {number}
   * @memberof UserInfo
   */
  userId: number;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  displayname: string;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  token: string;
}

/**
 *
 * @export
 * @interface Visibility
 */
export interface Visibility {
  /**
   *
   * @type {boolean}
   * @memberof Visibility
   */
  visibility?: boolean;
}

/**
 * AuthenticationApi - fetch parameter creator
 * @export
 */
export const AuthenticationApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get current user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser(options: any = {}): FetchArgs {
      const localVarPath = `/auth/current-user`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Login with username and password
     * @param {LoginCredentials} credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(credentials: LoginCredentials, options: any = {}): FetchArgs {
      // verify required parameter 'credentials' is not null or undefined
      if (credentials === null || credentials === undefined) {
        throw new RequiredError(
          'credentials',
          'Required parameter credentials was null or undefined when calling login.',
        );
      }
      const localVarPath = `/auth/login`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'LoginCredentials' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(credentials || {})
        : credentials || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Register a new user
     * @param {NewUser} accountInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    register(accountInfo: NewUser, options: any = {}): FetchArgs {
      // verify required parameter 'accountInfo' is not null or undefined
      if (accountInfo === null || accountInfo === undefined) {
        throw new RequiredError(
          'accountInfo',
          'Required parameter accountInfo was null or undefined when calling register.',
        );
      }
      const localVarPath = `/auth/register`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'NewUser' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(accountInfo || {})
        : accountInfo || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get current user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserInfo> {
      const localVarFetchArgs =
        AuthenticationApiFetchParamCreator(configuration).getCurrentUser(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json();
            } else {
              throw response;
            }
          },
        );
      };
    },
    /**
     *
     * @summary Login with username and password
     * @param {LoginCredentials} credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(
      credentials: LoginCredentials,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UserInfo> {
      const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).login(
        credentials,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json();
            } else {
              throw response;
            }
          },
        );
      };
    },
    /**
     *
     * @summary Register a new user
     * @param {NewUser} accountInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    register(
      accountInfo: NewUser,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).register(
        accountInfo,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response;
            } else {
              throw response;
            }
          },
        );
      };
    },
  };
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @summary Get current user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser(options?: any) {
      return AuthenticationApiFp(configuration).getCurrentUser(options)(fetch, basePath);
    },
    /**
     *
     * @summary Login with username and password
     * @param {LoginCredentials} credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(credentials: LoginCredentials, options?: any) {
      return AuthenticationApiFp(configuration).login(credentials, options)(fetch, basePath);
    },
    /**
     *
     * @summary Register a new user
     * @param {NewUser} accountInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    register(accountInfo: NewUser, options?: any) {
      return AuthenticationApiFp(configuration).register(accountInfo, options)(fetch, basePath);
    },
  };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
  /**
   *
   * @summary Get current user info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public getCurrentUser(options?: any) {
    return AuthenticationApiFp(this.configuration).getCurrentUser(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Login with username and password
   * @param {LoginCredentials} credentials
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public login(credentials: LoginCredentials, options?: any) {
    return AuthenticationApiFp(this.configuration).login(credentials, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Register a new user
   * @param {NewUser} accountInfo
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public register(accountInfo: NewUser, options?: any) {
    return AuthenticationApiFp(this.configuration).register(accountInfo, options)(
      this.fetch,
      this.basePath,
    );
  }
}

/**
 * ProfileApi - fetch parameter creator
 * @export
 */
export const ProfileApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get profile information for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfile(options: any = {}): FetchArgs {
      const localVarPath = `/profile`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get profile information for the given user
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfileByUserId(userId: number, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling getProfileByUserId.',
        );
      }
      const localVarPath = `/profile/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update address visibility
     * @param {Visibility} [visibility]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAddressVisibility(visibility?: Visibility, options: any = {}): FetchArgs {
      const localVarPath = `/profile/address/visibility`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Visibility' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(visibility || {})
        : visibility || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update profile information of the current user
     * @param {ProfileUpdateInfo} [profileInfo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProfile(profileInfo?: ProfileUpdateInfo, options: any = {}): FetchArgs {
      const localVarPath = `/profile`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'ProfileUpdateInfo' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(profileInfo || {})
        : profileInfo || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update status visibility
     * @param {Visibility} [visibility]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStatusVisibility(visibility?: Visibility, options: any = {}): FetchArgs {
      const localVarPath = `/profile/status/visibility`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Visibility' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(visibility || {})
        : visibility || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update telephone visibility
     * @param {Visibility} [visibility]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTelephoneVisibility(visibility?: Visibility, options: any = {}): FetchArgs {
      const localVarPath = `/profile/telephone/visibility`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'Visibility' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(visibility || {})
        : visibility || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get profile information for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfile(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ProfileInfoCurrentUser> {
      const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).getProfile(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json();
            } else {
              throw response;
            }
          },
        );
      };
    },
    /**
     *
     * @summary Get profile information for the given user
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfileByUserId(
      userId: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ProfileInfo> {
      const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).getProfileByUserId(
        userId,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json();
            } else {
              throw response;
            }
          },
        );
      };
    },
    /**
     *
     * @summary Update address visibility
     * @param {Visibility} [visibility]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAddressVisibility(
      visibility?: Visibility,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).updateAddressVisibility(
        visibility,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response;
            } else {
              throw response;
            }
          },
        );
      };
    },
    /**
     *
     * @summary Update profile information of the current user
     * @param {ProfileUpdateInfo} [profileInfo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProfile(
      profileInfo?: ProfileUpdateInfo,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).updateProfile(
        profileInfo,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response;
            } else {
              throw response;
            }
          },
        );
      };
    },
    /**
     *
     * @summary Update status visibility
     * @param {Visibility} [visibility]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStatusVisibility(
      visibility?: Visibility,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).updateStatusVisibility(
        visibility,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response;
            } else {
              throw response;
            }
          },
        );
      };
    },
    /**
     *
     * @summary Update telephone visibility
     * @param {Visibility} [visibility]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTelephoneVisibility(
      visibility?: Visibility,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ProfileApiFetchParamCreator(
        configuration,
      ).updateTelephoneVisibility(visibility, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response;
            } else {
              throw response;
            }
          },
        );
      };
    },
  };
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @summary Get profile information for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfile(options?: any) {
      return ProfileApiFp(configuration).getProfile(options)(fetch, basePath);
    },
    /**
     *
     * @summary Get profile information for the given user
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfileByUserId(userId: number, options?: any) {
      return ProfileApiFp(configuration).getProfileByUserId(userId, options)(fetch, basePath);
    },
    /**
     *
     * @summary Update address visibility
     * @param {Visibility} [visibility]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAddressVisibility(visibility?: Visibility, options?: any) {
      return ProfileApiFp(configuration).updateAddressVisibility(visibility, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary Update profile information of the current user
     * @param {ProfileUpdateInfo} [profileInfo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProfile(profileInfo?: ProfileUpdateInfo, options?: any) {
      return ProfileApiFp(configuration).updateProfile(profileInfo, options)(fetch, basePath);
    },
    /**
     *
     * @summary Update status visibility
     * @param {Visibility} [visibility]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStatusVisibility(visibility?: Visibility, options?: any) {
      return ProfileApiFp(configuration).updateStatusVisibility(visibility, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary Update telephone visibility
     * @param {Visibility} [visibility]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTelephoneVisibility(visibility?: Visibility, options?: any) {
      return ProfileApiFp(configuration).updateTelephoneVisibility(visibility, options)(
        fetch,
        basePath,
      );
    },
  };
};

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
  /**
   *
   * @summary Get profile information for the current user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfileApi
   */
  public getProfile(options?: any) {
    return ProfileApiFp(this.configuration).getProfile(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get profile information for the given user
   * @param {number} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfileApi
   */
  public getProfileByUserId(userId: number, options?: any) {
    return ProfileApiFp(this.configuration).getProfileByUserId(userId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Update address visibility
   * @param {Visibility} [visibility]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfileApi
   */
  public updateAddressVisibility(visibility?: Visibility, options?: any) {
    return ProfileApiFp(this.configuration).updateAddressVisibility(visibility, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Update profile information of the current user
   * @param {ProfileUpdateInfo} [profileInfo]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfileApi
   */
  public updateProfile(profileInfo?: ProfileUpdateInfo, options?: any) {
    return ProfileApiFp(this.configuration).updateProfile(profileInfo, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Update status visibility
   * @param {Visibility} [visibility]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfileApi
   */
  public updateStatusVisibility(visibility?: Visibility, options?: any) {
    return ProfileApiFp(this.configuration).updateStatusVisibility(visibility, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Update telephone visibility
   * @param {Visibility} [visibility]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfileApi
   */
  public updateTelephoneVisibility(visibility?: Visibility, options?: any) {
    return ProfileApiFp(this.configuration).updateTelephoneVisibility(visibility, options)(
      this.fetch,
      this.basePath,
    );
  }
}

/**
 * RequestApi - fetch parameter creator
 * @export
 */
export const RequestApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Accept the request with the given id
     * @param {number} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptRequest(requestId: number, options: any = {}): FetchArgs {
      // verify required parameter 'requestId' is not null or undefined
      if (requestId === null || requestId === undefined) {
        throw new RequiredError(
          'requestId',
          'Required parameter requestId was null or undefined when calling acceptRequest.',
        );
      }
      const localVarPath = `/request/others/{requestId}`.replace(
        `{${'requestId'}}`,
        encodeURIComponent(String(requestId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deny the request with the given id
     * @param {number} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    denyRequest(requestId: number, options: any = {}): FetchArgs {
      // verify required parameter 'requestId' is not null or undefined
      if (requestId === null || requestId === undefined) {
        throw new RequiredError(
          'requestId',
          'Required parameter requestId was null or undefined when calling denyRequest.',
        );
      }
      const localVarPath = `/request/others/{requestId}`.replace(
        `{${'requestId'}}`,
        encodeURIComponent(String(requestId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all requests the current user made
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRequestsByMe(options: any = {}): FetchArgs {
      const localVarPath = `/request/me`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all requests made for my offers by others
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRequestsByOthers(options: any = {}): FetchArgs {
      const localVarPath = `/request/others`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Make a request to get the item with the given offerId
     * @param {number} offerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestOffer(offerId: number, options: any = {}): FetchArgs {
      // verify required parameter 'offerId' is not null or undefined
      if (offerId === null || offerId === undefined) {
        throw new RequiredError(
          'offerId',
          'Required parameter offerId was null or undefined when calling requestOffer.',
        );
      }
      const localVarPath = `/request/{offerId}`.replace(
        `{${'offerId'}}`,
        encodeURIComponent(String(offerId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Take back the request with the given id the current user made
     * @param {number} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    takebackRequest(requestId: number, options: any = {}): FetchArgs {
      // verify required parameter 'requestId' is not null or undefined
      if (requestId === null || requestId === undefined) {
        throw new RequiredError(
          'requestId',
          'Required parameter requestId was null or undefined when calling takebackRequest.',
        );
      }
      const localVarPath = `/request/me/{requestId}`.replace(
        `{${'requestId'}}`,
        encodeURIComponent(String(requestId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RequestApi - functional programming interface
 * @export
 */
export const RequestApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Accept the request with the given id
     * @param {number} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptRequest(
      requestId: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = RequestApiFetchParamCreator(configuration).acceptRequest(
        requestId,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response;
            } else {
              throw response;
            }
          },
        );
      };
    },
    /**
     *
     * @summary Deny the request with the given id
     * @param {number} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    denyRequest(
      requestId: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = RequestApiFetchParamCreator(configuration).denyRequest(
        requestId,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response;
            } else {
              throw response;
            }
          },
        );
      };
    },
    /**
     *
     * @summary Get all requests the current user made
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRequestsByMe(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Request>> {
      const localVarFetchArgs = RequestApiFetchParamCreator(configuration).getRequestsByMe(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json();
            } else {
              throw response;
            }
          },
        );
      };
    },
    /**
     *
     * @summary Get all requests made for my offers by others
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRequestsByOthers(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Request>> {
      const localVarFetchArgs =
        RequestApiFetchParamCreator(configuration).getRequestsByOthers(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json();
            } else {
              throw response;
            }
          },
        );
      };
    },
    /**
     *
     * @summary Make a request to get the item with the given offerId
     * @param {number} offerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestOffer(
      offerId: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = RequestApiFetchParamCreator(configuration).requestOffer(
        offerId,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response;
            } else {
              throw response;
            }
          },
        );
      };
    },
    /**
     *
     * @summary Take back the request with the given id the current user made
     * @param {number} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    takebackRequest(
      requestId: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = RequestApiFetchParamCreator(configuration).takebackRequest(
        requestId,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response;
            } else {
              throw response;
            }
          },
        );
      };
    },
  };
};

/**
 * RequestApi - factory interface
 * @export
 */
export const RequestApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @summary Accept the request with the given id
     * @param {number} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptRequest(requestId: number, options?: any) {
      return RequestApiFp(configuration).acceptRequest(requestId, options)(fetch, basePath);
    },
    /**
     *
     * @summary Deny the request with the given id
     * @param {number} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    denyRequest(requestId: number, options?: any) {
      return RequestApiFp(configuration).denyRequest(requestId, options)(fetch, basePath);
    },
    /**
     *
     * @summary Get all requests the current user made
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRequestsByMe(options?: any) {
      return RequestApiFp(configuration).getRequestsByMe(options)(fetch, basePath);
    },
    /**
     *
     * @summary Get all requests made for my offers by others
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRequestsByOthers(options?: any) {
      return RequestApiFp(configuration).getRequestsByOthers(options)(fetch, basePath);
    },
    /**
     *
     * @summary Make a request to get the item with the given offerId
     * @param {number} offerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestOffer(offerId: number, options?: any) {
      return RequestApiFp(configuration).requestOffer(offerId, options)(fetch, basePath);
    },
    /**
     *
     * @summary Take back the request with the given id the current user made
     * @param {number} requestId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    takebackRequest(requestId: number, options?: any) {
      return RequestApiFp(configuration).takebackRequest(requestId, options)(fetch, basePath);
    },
  };
};

/**
 * RequestApi - object-oriented interface
 * @export
 * @class RequestApi
 * @extends {BaseAPI}
 */
export class RequestApi extends BaseAPI {
  /**
   *
   * @summary Accept the request with the given id
   * @param {number} requestId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public acceptRequest(requestId: number, options?: any) {
    return RequestApiFp(this.configuration).acceptRequest(requestId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Deny the request with the given id
   * @param {number} requestId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public denyRequest(requestId: number, options?: any) {
    return RequestApiFp(this.configuration).denyRequest(requestId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Get all requests the current user made
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public getRequestsByMe(options?: any) {
    return RequestApiFp(this.configuration).getRequestsByMe(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get all requests made for my offers by others
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public getRequestsByOthers(options?: any) {
    return RequestApiFp(this.configuration).getRequestsByOthers(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Make a request to get the item with the given offerId
   * @param {number} offerId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public requestOffer(offerId: number, options?: any) {
    return RequestApiFp(this.configuration).requestOffer(offerId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Take back the request with the given id the current user made
   * @param {number} requestId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RequestApi
   */
  public takebackRequest(requestId: number, options?: any) {
    return RequestApiFp(this.configuration).takebackRequest(requestId, options)(
      this.fetch,
      this.basePath,
    );
  }
}

/**
 * TradingApi - fetch parameter creator
 * @export
 */
export const TradingApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Add a new item offer
     * @param {NewOffer} offer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addOffer(offer: NewOffer, options: any = {}): FetchArgs {
      // verify required parameter 'offer' is not null or undefined
      if (offer === null || offer === undefined) {
        throw new RequiredError(
          'offer',
          'Required parameter offer was null or undefined when calling addOffer.',
        );
      }
      const localVarPath = `/offer`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'NewOffer' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(offer || {}) : offer || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete the offer with the given id that the current user uploaded
     * @param {number} offerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOffer(offerId: number, options: any = {}): FetchArgs {
      // verify required parameter 'offerId' is not null or undefined
      if (offerId === null || offerId === undefined) {
        throw new RequiredError(
          'offerId',
          'Required parameter offerId was null or undefined when calling deleteOffer.',
        );
      }
      const localVarPath = `/offer/{offerId}`.replace(
        `{${'offerId'}}`,
        encodeURIComponent(String(offerId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a list of items that are currently offered by the current user
     * @param {number} [page]
     * @param {'asc' | 'desc'} [nameOrder]
     * @param {'asc' | 'desc'} [creationOrder]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyOffers(
      page?: number,
      nameOrder?: 'asc' | 'desc',
      creationOrder?: 'asc' | 'desc',
      limit?: number,
      options: any = {},
    ): FetchArgs {
      const localVarPath = `/offer/me`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (nameOrder !== undefined) {
        localVarQueryParameter['nameOrder'] = nameOrder;
      }

      if (creationOrder !== undefined) {
        localVarQueryParameter['creationOrder'] = creationOrder;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get information on one particular offer
     * @param {number} offerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOffer(offerId: number, options: any = {}): FetchArgs {
      // verify required parameter 'offerId' is not null or undefined
      if (offerId === null || offerId === undefined) {
        throw new RequiredError(
          'offerId',
          'Required parameter offerId was null or undefined when calling getOffer.',
        );
      }
      const localVarPath = `/offer/{offerId}`.replace(
        `{${'offerId'}}`,
        encodeURIComponent(String(offerId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a list of items that are currently offered
     * @param {number} [page]
     * @param {'asc' | 'desc'} [nameOrder]
     * @param {'asc' | 'desc'} [creationOrder]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOffers(
      page?: number,
      nameOrder?: 'asc' | 'desc',
      creationOrder?: 'asc' | 'desc',
      limit?: number,
      options: any = {},
    ): FetchArgs {
      const localVarPath = `/offer`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('Authorization')
            : configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (nameOrder !== undefined) {
        localVarQueryParameter['nameOrder'] = nameOrder;
      }

      if (creationOrder !== undefined) {
        localVarQueryParameter['creationOrder'] = creationOrder;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TradingApi - functional programming interface
 * @export
 */
export const TradingApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Add a new item offer
     * @param {NewOffer} offer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addOffer(
      offer: NewOffer,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = TradingApiFetchParamCreator(configuration).addOffer(offer, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response;
            } else {
              throw response;
            }
          },
        );
      };
    },
    /**
     *
     * @summary Delete the offer with the given id that the current user uploaded
     * @param {number} offerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOffer(
      offerId: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = TradingApiFetchParamCreator(configuration).deleteOffer(
        offerId,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response;
            } else {
              throw response;
            }
          },
        );
      };
    },
    /**
     *
     * @summary Get a list of items that are currently offered by the current user
     * @param {number} [page]
     * @param {'asc' | 'desc'} [nameOrder]
     * @param {'asc' | 'desc'} [creationOrder]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyOffers(
      page?: number,
      nameOrder?: 'asc' | 'desc',
      creationOrder?: 'asc' | 'desc',
      limit?: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MyOffer>> {
      const localVarFetchArgs = TradingApiFetchParamCreator(configuration).getMyOffers(
        page,
        nameOrder,
        creationOrder,
        limit,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json();
            } else {
              throw response;
            }
          },
        );
      };
    },
    /**
     *
     * @summary Get information on one particular offer
     * @param {number} offerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOffer(
      offerId: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Offer> {
      const localVarFetchArgs = TradingApiFetchParamCreator(configuration).getOffer(
        offerId,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json();
            } else {
              throw response;
            }
          },
        );
      };
    },
    /**
     *
     * @summary Get a list of items that are currently offered
     * @param {number} [page]
     * @param {'asc' | 'desc'} [nameOrder]
     * @param {'asc' | 'desc'} [creationOrder]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOffers(
      page?: number,
      nameOrder?: 'asc' | 'desc',
      creationOrder?: 'asc' | 'desc',
      limit?: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Offer>> {
      const localVarFetchArgs = TradingApiFetchParamCreator(configuration).getOffers(
        page,
        nameOrder,
        creationOrder,
        limit,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json();
            } else {
              throw response;
            }
          },
        );
      };
    },
  };
};

/**
 * TradingApi - factory interface
 * @export
 */
export const TradingApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @summary Add a new item offer
     * @param {NewOffer} offer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addOffer(offer: NewOffer, options?: any) {
      return TradingApiFp(configuration).addOffer(offer, options)(fetch, basePath);
    },
    /**
     *
     * @summary Delete the offer with the given id that the current user uploaded
     * @param {number} offerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOffer(offerId: number, options?: any) {
      return TradingApiFp(configuration).deleteOffer(offerId, options)(fetch, basePath);
    },
    /**
     *
     * @summary Get a list of items that are currently offered by the current user
     * @param {number} [page]
     * @param {'asc' | 'desc'} [nameOrder]
     * @param {'asc' | 'desc'} [creationOrder]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyOffers(
      page?: number,
      nameOrder?: 'asc' | 'desc',
      creationOrder?: 'asc' | 'desc',
      limit?: number,
      options?: any,
    ) {
      return TradingApiFp(configuration).getMyOffers(
        page,
        nameOrder,
        creationOrder,
        limit,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get information on one particular offer
     * @param {number} offerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOffer(offerId: number, options?: any) {
      return TradingApiFp(configuration).getOffer(offerId, options)(fetch, basePath);
    },
    /**
     *
     * @summary Get a list of items that are currently offered
     * @param {number} [page]
     * @param {'asc' | 'desc'} [nameOrder]
     * @param {'asc' | 'desc'} [creationOrder]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOffers(
      page?: number,
      nameOrder?: 'asc' | 'desc',
      creationOrder?: 'asc' | 'desc',
      limit?: number,
      options?: any,
    ) {
      return TradingApiFp(configuration).getOffers(
        page,
        nameOrder,
        creationOrder,
        limit,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * TradingApi - object-oriented interface
 * @export
 * @class TradingApi
 * @extends {BaseAPI}
 */
export class TradingApi extends BaseAPI {
  /**
   *
   * @summary Add a new item offer
   * @param {NewOffer} offer
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradingApi
   */
  public addOffer(offer: NewOffer, options?: any) {
    return TradingApiFp(this.configuration).addOffer(offer, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Delete the offer with the given id that the current user uploaded
   * @param {number} offerId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradingApi
   */
  public deleteOffer(offerId: number, options?: any) {
    return TradingApiFp(this.configuration).deleteOffer(offerId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Get a list of items that are currently offered by the current user
   * @param {number} [page]
   * @param {'asc' | 'desc'} [nameOrder]
   * @param {'asc' | 'desc'} [creationOrder]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradingApi
   */
  public getMyOffers(
    page?: number,
    nameOrder?: 'asc' | 'desc',
    creationOrder?: 'asc' | 'desc',
    limit?: number,
    options?: any,
  ) {
    return TradingApiFp(this.configuration).getMyOffers(
      page,
      nameOrder,
      creationOrder,
      limit,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get information on one particular offer
   * @param {number} offerId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradingApi
   */
  public getOffer(offerId: number, options?: any) {
    return TradingApiFp(this.configuration).getOffer(offerId, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get a list of items that are currently offered
   * @param {number} [page]
   * @param {'asc' | 'desc'} [nameOrder]
   * @param {'asc' | 'desc'} [creationOrder]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradingApi
   */
  public getOffers(
    page?: number,
    nameOrder?: 'asc' | 'desc',
    creationOrder?: 'asc' | 'desc',
    limit?: number,
    options?: any,
  ) {
    return TradingApiFp(this.configuration).getOffers(
      page,
      nameOrder,
      creationOrder,
      limit,
      options,
    )(this.fetch, this.basePath);
  }
}
